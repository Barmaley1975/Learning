let myblock; // переменная вынесена в глобальную область видимости. необходимости в этом нет, просто мне так захотелось
let flag = false; // а эти переменные вынесены потому, что должны быть видны вне функции и сохранять свое значение между ее вызовами
let fix = {
    x: 0,
    y: 0
}

// нам нужно, чтобы наш код выполнялся тогда, когда наш блок уже отрисован. поэтому мы создаем слушатель события "DOMContentLoaded", который и запустит наш код после загрузки всего документа.
document.addEventListener('DOMContentLoaded', function(){
    /* здесь начало нашего кода */
    myblock = document.querySelector('.inner'); // выбираем наш блок. так делается для того, чтобы не искать его каждый раз, когда он нам понадобится. кроме того так короче писать.
    document.addEventListener('mousemove', function(e){ // блок должен реагировать на движение мыши
        if (flag) { // но только если мы в режиме перетаскивания - когда флаг поднят
            // прописываем в свойствах блока параметры, соответствующие новому положению мыши
            myblock.style.left = (e.clientX - fix.x) + 'px';
            myblock.style.top = (e.clientY - fix.y) + 'px';
        }
    });
    myblock.onmousedown = function(e){ // включаем режим перетаскивания по нажатию кнопки мыши на блоке
        if (!flag) { // если флаг опущен (то есть движения сейчас нет)
            flag = true; // поднимаем флаг
            // фиксируем разницы в положении между блоком и курсором мыши - чтобы блок не прыгнул со своего места на место мыши
            fix.x = e.clientX - myblock.getBoundingClientRect().x;
            fix.y = e.clientY - myblock.getBoundingClientRect().y;
        } // а если флаг поднят, никаких действий не требуется - этот код исполняется только в начале перетаскивания
    };
    document.onmouseup = function(){
        flag = false; // если кнопка мыши отпущена, флаг убирается
    };
    /* здесь конец нашего кода */
});